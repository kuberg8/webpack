<section class="container lead">
  <h1 class="pt-4 pb-5">JavaScript</h1>
  <article class="pb-5">
    <h2>Типы и Структуры данных</h2>
    <hr /> 
      <p class="p">
        <iframe
        height="350"
        src="https://www.youtube.com/embed/dFwNSyVC_5Y"
        title="YouTube video player"
        frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen
        style="min-width: 50%"
        class="frame"
      ></iframe>
        Все языки программирования содержат встроенные типы данных, но они часто
        отличаются друг от друга в разных языках. На их основе строятся другие
        структуры данных. 
        Встроенные структуры (типы) данных, доступные в
        JavaScript, стандарт ECMAScript определяет 9 типов:
      </p>
      <p class="p">
        <ul>
          <b>Примитивы:</b>
          <li>Undefined (Неопределённый тип)</li>
          <li>Boolean (Булев, Логический тип) </li>
          <li>Number (Число)</li>
          <li>String (Строка)</li>
          <li>BigInt</li>
          <li>Symbol</li>
          <b>Ссылочные типы:</b>
          Null, Object, Fuction
        </ul>
      </p>
      <p class="p">
        Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».
      </p>
      <p class="p">
        <b>Ссылочный тип данных</b> - это значение в памяти, на которое возможно сослаться с помощью идентификатора. Все другие структуры данных, такие как Функции (Functions), Массивы (Arrays), Коллекции (Maps, Sets, WeakMaps, WeakSets) и т.д. тоже являются объектами.
        Подробнее <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures" target="_blank">тут</a> и <a href="http://jsflow.org/docs/types/" target="_blank">тут</a>.
      </p>
  </article>

  <article class="pb-5">
    <h2>Контекст, область видимости и замыкание</h2>
    <hr />
    <p class="p"><b>Контекст выполнения</b> (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы. 
    <b>this</b> — это ключевое слово, которое ссылается на объект, в зависимости от контекста функции в которой оно было вызвано.</p>
    <p class="p"><b>[[Scope]]</b> - это скрытое внутреннее свойство функции, которое она получает во время вызова. Данное свойство содержит ссылку на ту область видимости, в которой данная функция была объявлена.</p>
    <p class="p">
      <b>Область видимости</b> - это область где компилятор ищет переменные и функции
      во время вызовав, если не находит в текущей области, то интерпретатор посредством [[Scope]] перейдёт в родительскую область и попытается найти её там. Компилятор - это программа, которая переводит текст языка
      программирования в набор машинных кодов.
      <a href="https://habr.com/ru/post/338462/" target="_blank">Подробнее</a>.
    </p>
    <p class="p">
      <b>Замыкание</b> - это когда функцию возвращает другую функцию, таким образом
      функция замкнута на область видимости родительской функции.
    </p>
  </article>

  <article class="pb-5">
    <h2>Асинхронность и Eventloop</h2>
    <hr />
    <p class="p">
      <b>Асинхронность</b> - это выполнение долгих операций без блокировки основного потока.
      <b>Eventloop / событийный цикл</b> - бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.
      <a href="http://latentflip.com/loupe" target="_blank">Пример.</a>
    </p>
    <p class="p">
      Web API и JavaScrtipt движок работают независимо. Web API решает, в какой момент функция двигается дальше, в очередь вызовов.
      Функции в очереди вызовов попадают в JavaScript-движок, где выполняются по одной. Выполнение происходит в том же порядке, в котором функции попадают в очередь.
      Окружение самостоятельно решает, когда добавить переданный ей код в очередь вызовов. Функции из очереди добавляются в стек выполнения (выполняются) не раньше, чем стек вызовов закончит работу над текущей функцией.
      Таким образом, стек вызовов работает синхронно, а web API асинхронно.
    </p>
    <p class="p">
      <b>Макрозадачи и Микрозадачи</b> - сначала выполняются микрозадачи, а потом макро. К микро относятся Promise..., к макро браузерные события, timeout..
    </p>
      <img class="iframe" src="https://habrastorage.org/r/w1560/files/1f2/b37/3a6/1f2b373a6a7e4b889e1eb18c270bcfe8.png" />
  </article>

  <article class="pb-5">
    <h2>Прототипное наследование</h2>
    <hr />
    <p class="p">
      Это стиль ООП в котором наследование базового класса к производному
      происходит путём передачи прототипа. <b>_proto_</b> — это скрытое свойство
      объекта которое ссылается на prototype класса с помощью которого этот
      объект был создан, оно есть у любого объекта.
    </p>
    <p class="p">
      <b>Prototype</b> — это объект с определенным набором свойств и методов
      который доступен по скрытому свойству всех объектов __proto__.
    </p>
    <p class="p">
      Примитивы получают доступ к прототипу через объект-обертку которая
      создаётся при обращении к свойству примитива, после отработки
      объект-обертка удаляется оставляя примитив таким же «лёгким» без затрат
      дополнительных ресурсов как с объектами
    </p>
  </article>

  <article class="pb-5">
    <h2>Всплытие и погружение</h2>
    <hr />
    <p class="p">
      Когда на элементе происходит событие, обработчики сначала срабатывают на
      нём, потом на его родителе, затем выше и так далее, вверх по цепочке
      предков. Для остановки всплытия нужно вызвать метод
      event.stopPropagation(). Существует ещё одна фаза из жизненного цикла
      события – «погружение» (иногда её называют «перехват»). Она очень редко
      используется в реальном коде, однако тоже может быть полезной.
      <a
        href="https://learn.javascript.ru/bubbling-and-capturing"
        target="_blank"
        >Подробнее</a
      >.
    </p>
  </article>

  <article class="pb-5">
    <h2>Делегирование событий</h2>
    <hr />
    <p class="p pb-5">
      Всплытие и перехват событий позволяет реализовать один из самых важных
      приёмов разработки – делегирование. Идея в том, что если у нас есть много
      элементов, события на которых нужно обрабатывать похожим образом, то
      вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик
      на их общего предка.
      <a href="https://learn.javascript.ru/event-delegation" target="_blank"
        >Подробнее</a
      >.
    </p>
  </article>
</section>
