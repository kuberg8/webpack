<section class="container lead">
  <h1 class="pt-4 pb-5">JavaScript</h1>
  <article class="pb-5">
    <h2>Типы и Структуры данных</h2>
    <hr /> 
      <p class="p">
        <iframe
        height="350"
        src="https://www.youtube.com/embed/dFwNSyVC_5Y"
        title="YouTube video player"
        frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen
        style="min-width: 50%"
        class="frame"
      ></iframe>
        Все языки программирования содержат встроенные типы данных, но они часто
        отличаются друг от друга в разных языках. На их основе строятся другие
        структуры данных. 
        Встроенные структуры (типы) данных, доступные в
        JavaScript, стандарт ECMAScript определяет 9 типов:
      </p>
      <p class="p">
        <ul>
          <b>Примитивы:</b>
          <li>Undefined (Неопределённый тип)</li>
          <li>Boolean (Булев, Логический тип) </li>
          <li>Number (Число)</li>
          <li>String (Строка)</li>
          <li>BigInt</li>
          <li>Symbol</li>
          <b>Ссылочные типы:</b>
          Null, Object, Fuction
        </ul>
      </p>
      <p class="p">
        Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».
      </p>
      <p class="p">
        <b>Ссылочный тип данных</b> - это значение в памяти, на которое возможно сослаться с помощью идентификатора. Все другие структуры данных, такие как Функции (Functions), Массивы (Arrays), Коллекции (Maps, Sets, WeakMaps, WeakSets) и т.д. тоже являются объектами.
        Подробнее <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures" target="_blank">тут</a> и <a href="http://jsflow.org/docs/types/" target="_blank">тут</a>.
      </p>

      <p class="p">
        Оболочка, которая предоставляет доступ к методам прототипа для примитивных типов данных в JavaScript, называется "объект-обертка" или "wrapper object". Когда вы обращаетесь к методам для примитивного типа данных, JavaScript автоматически создает объект-обертку с соответствующими методами прототипа, чтобы вы могли использовать эти методы. Например, для строки создается объект-обертка String, для числа - Number, для булевого значения - Boolean и т.д.
      </p>
  </article>

  <article class="pb-5">
    <h2>Контекст, область видимости и замыкание</h2>
    <hr />
    <p class="p"><b>Контекст выполнения</b> (execution context) в JavaScript используется для того, чтобы отслеживать ход выполнения кода. Именно с его помощью определяется доступное окружение на текущем этапе выполнения программы. 
    <b>this</b> — это ключевое слово, которое ссылается на объект, в зависимости от контекста функции в которой оно было вызвано.</p>
    <p class="p"><b>[[Scope]]</b> - это скрытое внутреннее свойство функции, которое она получает во время вызова. Данное свойство содержит ссылку на ту область видимости, в которой данная функция была объявлена.</p>
    <p class="p">
      <b>Область видимости</b> - это область где компилятор ищет переменные и функции
      во время вызовав, если не находит в текущей области, то интерпретатор посредством [[Scope]] перейдёт в родительскую область и попытается найти её там. Компилятор - это программа, которая переводит текст языка
      программирования в набор машинных кодов.
      <a href="https://habr.com/ru/post/338462/" target="_blank">Подробнее</a>.
    </p>
    <p class="p">
      <b>Блочная область видимости переменных</b>
       - это концепция, которая определяет область действия переменных в JavaScript внутри блока кода, ограниченного фигурными скобками {}. Другими словами, переменные, объявленные внутри блока кода, будут доступны только внутри этого блока и не будут видны за его пределами.
    </p>
    <p class="p">
      <b>Замыкание</b> - это когда функцию возвращает другую функцию, таким образом
      функция замкнута на область видимости родительской функции.
    </p>
  </article>

  <article class="pb-5">
    <h2>Асинхронность и Eventloop</h2>
    <hr />
    <p class="p">
      <b>Асинхронность</b> - это выполнение долгих операций без блокировки основного потока.
      <b>Eventloop / событийный цикл</b> - бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.
      <a href="http://latentflip.com/loupe" target="_blank">Пример.</a>
    </p>
    <p class="p">
      Web API и JavaScrtipt движок работают независимо. Web API решает, в какой момент функция двигается дальше, в очередь вызовов.
      Функции в очереди вызовов попадают в JavaScript-движок, где выполняются по одной. Выполнение происходит в том же порядке, в котором функции попадают в очередь.
      Окружение самостоятельно решает, когда добавить переданный ей код в очередь вызовов. Функции из очереди добавляются в стек выполнения (выполняются) не раньше, чем стек вызовов закончит работу над текущей функцией.
      Таким образом, стек вызовов работает синхронно, а web API асинхронно.
    </p>
    <p class="p">
      <b>Макрозадачи и Микрозадачи</b> - сначала выполняются микрозадачи, а потом макро. К микро относятся Promise..., к макро браузерные события, timeout..
    </p>
      <img class="iframe" src="https://habrastorage.org/r/w1560/files/1f2/b37/3a6/1f2b373a6a7e4b889e1eb18c270bcfe8.png" />
  </article>

  <article class="pb-5">
    <h2>Прототипное наследование</h2>
    <hr />
    <p class="p">
      Это стиль ООП в котором наследование базового класса к производному
      происходит путём передачи прототипа. <b>_proto_</b> — это скрытое свойство
      объекта которое ссылается на prototype класса с помощью которого этот
      объект был создан, оно есть у любого объекта.
    </p>
    <p class="p">
      <b>Prototype</b> — это объект с определенным набором свойств и методов
      который доступен по скрытому свойству всех объектов __proto__.
    </p>
    <p class="p">
      Примитивы получают доступ к прототипу через объект-обертку которая
      создаётся при обращении к свойству примитива, после отработки
      объект-обертка удаляется оставляя примитив таким же «лёгким» без затрат
      дополнительных ресурсов как с объектами
    </p>
  </article>

  <article class="pb-5">
    <h2>Всплытие и погружение</h2>
    <hr />
    <p class="p">
      Когда на элементе происходит событие, обработчики сначала срабатывают на
      нём, потом на его родителе, затем выше и так далее, вверх по цепочке
      предков. Для остановки всплытия нужно вызвать метод
      event.stopPropagation(). Существует ещё одна фаза из жизненного цикла
      события – «погружение» (иногда её называют «перехват»). Она очень редко
      используется в реальном коде, однако тоже может быть полезной.
      <a
        href="https://learn.javascript.ru/bubbling-and-capturing"
        target="_blank"
        >Подробнее</a
      >.
    </p>
  </article>

  <article class="pb-5">
    <h2>Делегирование событий</h2>
    <hr />
    <p class="p">
      Всплытие и перехват событий позволяет реализовать один из самых важных
      приёмов разработки – делегирование. Идея в том, что если у нас есть много
      элементов, события на которых нужно обрабатывать похожим образом, то
      вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик
      на их общего предка.
      <a href="https://learn.javascript.ru/event-delegation" target="_blank"
        >Подробнее</a
      >.
    </p>
  </article>

  <article class="pb-5">
    <h2>Функции</h2>
    <hr />
    <small>
      <ul>
        <h6>(Стреолчные vs Обычные) => {</h6>
        <li>this: у обычной он динамический(зависит от способа вызова); у стрелочной он всегда равен this внешней функции</li>
        <li>у обычной функции есть конструктор который может создать объект - new FuncName()</li>
        <li>arguments - внутри тела обыкновенной функции, существует специальный массив arguments содержащий список аргументов с которым функция была вызвана.</li>
        <li>у стрелочной функции есть неявный return - () => someValue</li>
        <h6>}</h6>
      </ul>
    </small>
    <small>
      <ul>
        <h6>для привязки контекста - (call, bind, apply) => {</h6>
          <li>bind возвращает функцию, которая будет действовать как исходная функция, но с предопределенным значением this</li>
        <li>call - запускает функцию, используя первый аргумент как её контекст this, а последующие – как её аргументы.</li>
        <li>Единственная разница в синтаксисе между call и apply состоит в том, что call ожидает список аргументов, в то время как apply принимает псевдомассив.</li>
        <h6>}</h6>
        <a href="https://learn.javascript.ru/call-apply-decorators">Подробнее.</a>
      </ul>
    </small>
    <p class="p">
    </p>
  </article>

  <article class="pb-5">
    <h2>RESTful API</h2>
    <hr />
    <small>
      <p class="p">
        <b>RESTful API</b> - это подход к проектированию веб-сервисов, который основан на REST (Representational State Transfer). Его основные принципы: использование HTTP методов (GET, POST, PUT, DELETE), уникальный URL для каждого ресурса, использование стандартных форматов данных, таких как JSON или XML.
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>Улучшения производительности веб-приложения</h2>
    <hr />
    <small>
      <p class="p">
        Для улучшения производительности веб-приложения можно использовать сжатие ресурсов, кэширование файлов, оптимизацию изображений, асинхронную загрузку скриптов и стилей, а также изучение и устранение узких мест в коде.
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>Что такое MVC и как оно применяется во фронтенд разработке?</h2>
    <hr />
    <small>
      <p class="p">
        MVC (Model-View-Controller) - это паттерн проектирования, который разделяет приложение на три основные части: Модель (хранит данные), Представление (отображает данные) и Контроллер (управляет взаимодействием с пользователем). Во фронтенд разработке этот паттерн часто используется для организации кода и разделения логики.
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>SOLID, KISS, DRY</h2>
    <hr />
    <small>
      <p class="p">
        <ul>
          <li>
            S - Принцип единственной ответственности (Single Responsibility Principle). Этот принцип утверждает, что каждый класс должен иметь только одну ответственность.
          </li>
          <li>
            О - Принцип открытости/закрытости (Open/Closed Principle). Согласно этому принципу, программные сущности должны быть открыты для расширения, но закрыты для модификации.
          </li>
          <li>
            L - Принцип подстановки Барбары Лисков (Liskov Substitution Principle). Суть данного принципа заключается в том, что объекты базового класса должны быть заменяемы объектами его подклассов без изменения ожидаемого поведения программы.
          </li>
          <li>
            I - Принцип разделения интерфейса (Interface Segregation Principle). Этот принцип утверждает, что интерфейсы должны быть специфичными для определенных клиентов. Лучше создавать несколько узкоспециализированных интерфейсов, чем один общий, который имеет слишком много функций.
          </li>
          <li>
            D - Принцип инверсии зависимостей (Dependency Inversion Principle). Согласно этому принципу, классы должны зависеть от абстракций, а не от конкретных реализаций. Это позволяет уменьшить связанность между компонентами и делает код более гибким и легко масштабируемым.
          </li>
        </ul>
        KISS - keep it simple, stupid
        <br>
        DRY - dont repeat ursalfe
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>Тестирования веб-приложений</h2>
    <hr />
    <small>
      <p class="p">
        Для тестирования веб-приложений часто используются автоматизированные тесты, юнит-тесты, интеграционные тесты, тестирование с использованием фреймворков, таких как Jest, Mocha, Selenium, Puppeteer и другие.
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>CSS и препроцессоры</h2>
    <hr />
    <small>
      <p class="p">
        В CSS стилях применяется иерархия и наследование: свойства унаследованные от родительских элементов могут быть применены к потомкам, а также можно использовать селекторы для точного определения стилей для конкретных элементов.
      </p>
      <p class="p">
        CSS препроцессоры, такие как Sass или Less, позволяют использовать переменные, вложенность стилей, миксины, модульность и другие расширенные функции, которые помогают упростить и ускорить процесс написания CSS стилей.
      </p>
    </small>
  </article>

  <article class="pb-5">
    <h2>ES5 (ECMAScript 5) и ES6 (ECMAScript 2015)</h2>
    <hr />
    <small>
      <ul>
        <li>
          <b>
            Объявление переменных:
          </b>
            ES5 использует ключевые слова var для объявления переменных, в то время как ES6 дополнил это ключевыми словами let и const, позволяющими объявлять переменные с блочной областью видимости.
        </li>
        <li>
          <b>
            Стрелочные функции: 
          </b>
            ES6 ввел стрелочные функции (arrow functions), предоставляя более краткий и удобный синтаксис для создания функций.
        </li>
        <li>
          <b>
            Классы: 
          </b>
            В ES6 появилась возможность создания классов в JavaScript, что делает работу с объектно-ориентированным программированием более удобной и привычной.
        </li>
        <li>
          <b>
            Деструктуризация:
          </b>
           ES6 добавил возможность деструктурировать объекты и массивы, что упрощает доступ к их элементам.
        </li>
        <li>
          <b>
            Шаблонные строки: 
          </b>
            ES6 предоставил новый способ работы со строками, используя шаблонные строки (template literals), которые позволяют встраивать выражения и переменные непосредственно в строку.
        </li>
        <li>
          <b>
            Параметры по умолчанию: 
          </b>
          ES6 позволяет задавать значения по умолчанию для параметров функций, что делает код более чистым и понятным.
        </li>
        <li>
          <b>
            Spread и Rest операторы:
          </b>
           ES6 ввел операторы ..., которые упрощают работу с массивами и объектами, позволяя распространять элементы или аргументы функции.
        </li>
        <li>
          <b>
            Возможность работы с Promise:
          </b>
           ES6 добавил в стандарт возможность работы с промисами (Promises), что упрощает асинхронное программирование.
        </li>
        <li>
          <b>
            Модули: 
          </b>
          ES6 представил новую систему модулей, которая позволяет организовывать код в более структурированном и модульном виде.
        </li>
        <li>
          <b>
            Новые методы массивов:
          </b>
           ES6 добавил новые методы массивов, такие как map, filter, reduce, find, forEach и другие, облегчающие работу с массивами и обработку данных.
        </li>
        <li>
          <b>
            Импорт и экспорт модулей:
          </b>
           В ES6 появилась возможность импорта и экспорта модулей, что способствует организации кода на разные файлы и улучшает его масштабируемость.
        </li>
        <li>
          <b>
            Генераторы: 
          </b>
          ES6 ввел концепцию генераторов, позволяющих создавать итерируемые объекты с возможностью приостановить и возобновить выполнение кода.
        </li>
        <li>
          <b>
            Промисы:
          </b>
           ES6 добавил промисы как новый способ работы с асинхронным кодом, упрощая обработку асинхронных операций.
        </li>
        <li>
          <b>
            Локальные модули: 
          </b>
          ES6 поддерживает локальные модули, что позволяет организовывать код в более локальных и изолированных контекстах.
        </li>
        <li>
          <b>
            Symbol:
          </b>
           В ES6 появился новый примитивный тип данных Symbol, который позволяет создавать уникальные идентификаторы.
        </li>
        <li>
          <b>
            Proxy и Reflect: 
          </b>
          ES6 добавил возможность создания прокси-объектов (Proxy), которые позволяют перехватывать и изменять поведение объектов, а также добавил новый API Reflect, облегчающий многие операции над объектами.
        </li>
        <li>
          <b>
            Set и Map:
          </b>
           ES6 ввел новые структуры данных Set и Map, предоставляющие удобные методы для работы с уникальными значениями и коллекциями пар ключ-значение.
        </li>
        <li>
          <b>
            Усовершенствования в работе с объектами:
          </b>
           В ES6 появилась возможность удобно объявлять методы объектов, используя сокращенный синтаксис и возможность создания вычисляемых свойств.
        </li>
      </ul>
    </small>
    <p class="p">
    </p>
  </article>

  <article class="pb-5">
    <h2>Vue</h2>
    <hr />
    <small>
      <p class="p">
        Vue 3 представляет собой значительное обновление с новым компилятором, улучшенной производительностью, новой системой реактивности, композиционным API, более компактным кодом и другими улучшениями.
      </p>
      <p class="p">
        В Vue 3 с появлением Composition API: Composition API позволяет создавать компоненты более гибко и масштабируемо, разделять логику на отдельные куски, улучшает читаемость и переиспользование кода.
      </p>
      <br>
      <p class="p">
        Teleport в Vue 3 и для чего его используют: Teleport в Vue 3 позволяет перемещать дочерние компоненты в DOM-дереве за пределы родительского компонента без нарушения порядка иерархии компонентов. Это удобно для создания модальных окон, всплывающих подсказок и других интерфейсных элементов.
      </p>
      <br>
      <p class="p">
        Директивы в Vue.js используются для добавления определенного поведения к DOM элементам или их манипуляции без создания нового компонента. Директивы предоставляют прямое управление DOM и позволяют реагировать на события жизненного цикла элементов. Например, директива v-if позволяет условно отображать элемент на основе значения выражения.
        Примеры встроенных директив в Vue.js:
        
        <ul>
          <li>
            v-if - условное отображение элемента
          </li>
          <li>
            v-for - отображение элементов в цикле
          </li>
          <li>
            v-bind - привязка данных к элементу
          </li>
          <li>
            v-on - прослушивание событий
          </li>
          <li>
            v-model - обеспечение двусторонней привязки данных
          </li>
        </ul>
        
        <ul>
          Для оптимизации производительности Vue.js приложения можно использовать следующие подходы:
          <li>
            Ленивая загрузка компонентов или роутов по требованию с помощью динамического импорта.
          </li>
          <li>
            Оптимизация обновлений DOM с помощью ключей и избегание лишних перерисовок.
          </li>
          <li>
            Использование виртуального списка для отображения больших объемов данных.
          </li>
          <li>
            Кеширование данных запросов с помощью Vuex или других инструментов.
          </li>
          <li>
            Минимизация количества обращений к API и оптимизация запросов.
          </li>
          <li>
            Обработка ошибок и исключений для предотвращения сбоев и утечек памяти.
          </li>
          <li>
            Анализ и оптимизация производительности с помощью инструментов разработчика, например, Vue Devtools или Chrome DevTools.
          </li>
        </ul>
      </p>
    </small>
  </article>
</section>
